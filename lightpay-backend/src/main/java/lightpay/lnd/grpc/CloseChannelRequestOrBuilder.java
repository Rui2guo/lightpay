// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

package lightpay.lnd.grpc;

public interface CloseChannelRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:lnrpc.CloseChannelRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   **
   *The outpoint (txid:index) of the funding transaction. With this value, Bob
   *will be able to generate a signature for Alice's version of the commitment
   *transaction.
   * </pre>
   *
   * <code>.lnrpc.ChannelPoint channel_point = 1;</code>
   */
  boolean hasChannelPoint();
  /**
   * <pre>
   **
   *The outpoint (txid:index) of the funding transaction. With this value, Bob
   *will be able to generate a signature for Alice's version of the commitment
   *transaction.
   * </pre>
   *
   * <code>.lnrpc.ChannelPoint channel_point = 1;</code>
   */
  lightpay.lnd.grpc.ChannelPoint getChannelPoint();
  /**
   * <pre>
   **
   *The outpoint (txid:index) of the funding transaction. With this value, Bob
   *will be able to generate a signature for Alice's version of the commitment
   *transaction.
   * </pre>
   *
   * <code>.lnrpc.ChannelPoint channel_point = 1;</code>
   */
  lightpay.lnd.grpc.ChannelPointOrBuilder getChannelPointOrBuilder();

  /**
   * <pre>
   *&#47; If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
   * </pre>
   *
   * <code>bool force = 2;</code>
   */
  boolean getForce();

  /**
   * <pre>
   *&#47; The target number of blocks that the closure transaction should be confirmed by.
   * </pre>
   *
   * <code>int32 target_conf = 3;</code>
   */
  int getTargetConf();

  /**
   * <pre>
   *&#47; A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
   * </pre>
   *
   * <code>int64 sat_per_byte = 4;</code>
   */
  long getSatPerByte();
}
